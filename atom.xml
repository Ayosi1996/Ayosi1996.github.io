<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ayosi1996.github.io</id>
    <title>Sqrt9</title>
    <updated>2020-03-17T07:48:47.516Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ayosi1996.github.io"/>
    <link rel="self" href="https://ayosi1996.github.io/atom.xml"/>
    <subtitle>Hi there!</subtitle>
    <logo>https://ayosi1996.github.io/images/avatar.png</logo>
    <icon>https://ayosi1996.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Sqrt9</rights>
    <entry>
        <title type="html"><![CDATA[混合模式]]></title>
        <id>https://ayosi1996.github.io/post/blend-mode/</id>
        <link href="https://ayosi1996.github.io/post/blend-mode/">
        </link>
        <updated>2020-02-01T17:21:58.000Z</updated>
        <summary type="html"><![CDATA[<p>数字图像编辑和计算机图形学中的混合模式用于决定两个层之间如何相互混合。</p>
]]></summary>
        <content type="html"><![CDATA[<p>数字图像编辑和计算机图形学中的混合模式用于决定两个层之间如何相互混合。</p>
<!-- more -->
<h1 id="when">When</h1>
<p>在大概1994年Photoshop 3.0的时候引入了混合模式，最初有19个混合模式。</p>
<h1 id="how">How</h1>
<p>背景层 (Base)：图片中起始的颜色，通常为下层<br>
混合层 (Blend)：用于决定两个层之间的颜色如何混合，通常为上层<br>
结果 (Result): 结果即为两个层混合之后得到的颜色</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200317013321423.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="math">Math</h1>
<p>在本文中用<strong>M</strong>来表示混合层的颜色，用<strong>I</strong>来表示背景层的颜色，<strong>E</strong>代表混合之后得到的结果<br>
文章中提到的白色为纯白，即（255,255,255）黑色为纯黑色，即（0,0,0）</p>
<p>例如：<br>
“正片叠底”的公式为：</p>
<center><b>E = M * I / 255</b></center>
<br>
<h1 id="begin">Begin</h1>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200317103845120.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>上面的两张图片代表混合层，下面的图片代表背景层<br>
所有混合模式将基于上面的图片进行演示</p>
<h1 id="normal">Normal</h1>
<h2 id="正常">正常</h2>
<p>“正常”混合模式是大多数软件默认的混合模式，即直接显示混合层的图像，如果想要显示背景层的图像，可以降低混合层的透明度。</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200317104432531.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="溶解">溶解</h2>
<p>“溶解”模式和正常模式很像，区别在于当降低混合层透明度时，背景层图像的像素以一种随机的方式显示出来，显示的强度取决于混合层的不透明度，即混合层越透明，背景层显示的像素越多</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200317105137753.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="darken">Darken</h1>
<p>这些混合模式都会使图片变得更暗，混合层的白颜色会变得不可见，混合层的其他颜色会变得更暗。</p>
<h2 id="变暗">变暗</h2>
<center><b>E = min(M, I)</b></center>
<br>
即该混合模式会对比每个像素的RGB通道值，然后选择较小的一个，例如混合层某一像素为（15，120，30），与之对应的背景层的像素为（20，56, 14)，则新产生的像素为（15，56，14）
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200317110756182.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="正片叠底">正片叠底</h2>
<p>“正片叠底”是最常用到的一种混合模式。</p>
<center><b>E = M * I / 255</b></center>
<br>
通过公式可以得出如果为白色像素，则会显示另一层的像素，如果为黑色像素，则会依然显示黑色，其他颜色则会变得更暗。
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200317111501648.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="颜色加深">颜色加深</h2>
<p><img src="https://img-blog.csdnimg.cn/20200317112732590.png" alt="在这里插入图片描述" loading="lazy"><br>
“颜色加深”会得出一个比正片叠底更暗的结果，会使中间调更加饱和，并减少高光。</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200317113048541.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="线性加深">线性加深</h2>
<center><b>E = (M + I) - 255</b></center>
<br>
"线性加深”得出的结果比正片叠底暗，但饱和度比“颜色加深”低。该模式能在图片较暗的部分产生较大的对比度。
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200317113729348.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="深色">深色</h2>
<p>“深色”与“变暗”模式很像，区别在于&quot;深色&quot;不是对像素的每个通道作比较，而是对整个像素的亮度作比较然后保留较暗的一个。<br>
通过RGB计算亮度一种常用的公式为：</p>
<center><b>L = 0.2126*R + 0.7152 *G + 0.0722*B</b></center>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2020031711470856.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="lighten">Lighten</h1>
<p>这些混合模式都会得到一个更亮的结果，混合层黑色部分会变透明，其他颜色部分会变得更亮。</p>
<h2 id="变亮">变亮</h2>
<center><b>E = max(M, I)</b></center>
<br>
“变亮”的计算方式与“变暗”相同，但“变亮”取得是每个通道中较大的一个。例如混合层某一像素为（15，120，30），与之对应的背景层的像素为（20，56, 14)，则新产生的像素为（20，120，30）
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200317115516169.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="滤色">滤色</h2>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200317115647483.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>“滤色”也是PS种较常用的一种混合模式，得到的结果始终是较亮的颜色，黑色部分不会发生变化，较亮的像素会保留。该模式可用于增量图像或者创建高光。<br>
<img src="https://img-blog.csdnimg.cn/20200317120107746.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="颜色减淡">颜色减淡</h2>
<p><img src="https://img-blog.csdnimg.cn/20200317121357626.png" alt="在这里插入图片描述" loading="lazy"><br>
通过降低背景层和混合层之间的对比度，“彩色减淡”混合模式可以得到一个比“滤色”更亮的效果，从而产生饱和的中间调和高光。<br>
<img src="https://img-blog.csdnimg.cn/20200317121731182.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="线性减淡添加">线性减淡（添加）</h2>
<center><b>E = M + I</b></center>
<br>
该公式作用于每个像素的每个通道
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/2020031712222467.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="浅色">浅色</h2>
<p>“浅色”与“深色”相反，对比两个像素的亮度值（不是每个通道），保留亮度值较高的像素。</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200317122356339.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="contrast">Contrast</h1>
<p>此类别中的混合模式是“变暗”和“变亮”混合模式之间的混合。 通过使用互补的混合模式创建混合，它们通过使结果颜色变亮和变暗来创建对比度。</p>
<p>这类模式中50%灰色，即(128,128,128)，会非常常见，为了方便，以下统称该色为“中性灰”。</p>
<p>Photoshop中会检查颜色是比中性灰暗还是亮。 如果比中性灰暗，则将应用变暗的混合模式。 如果颜色比中性灰亮，则应用变亮的混合模式。</p>
<h2 id="叠加">叠加</h2>
<center><b>E = M * I / 128  </b>&emsp;当 I<128时</center>
<center><b>E = 255 - (255 - M) * (255 - I) / 128   </b>&emsp;当 I>=128时</center>
<br>
叠加是Photoshop中使用最广泛的混合模式之一。它是“正片叠底”和“滤色”的混合。背景层中较亮的部分会变得更亮，较暗的部分会变得更暗。中性灰部分不受影响。
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200317124319179.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="todo">TODO:</h1>
<h2 id="柔光">柔光</h2>
<h2 id="强光">强光</h2>
<h2 id="亮光">亮光</h2>
<h2 id="线性光">线性光</h2>
<h2 id="点光">点光</h2>
<h2 id="实色混合">实色混合</h2>
<h1 id="inversion">Inversion</h1>
<h2 id="差值">差值</h2>
<h2 id="排除">排除</h2>
<h2 id="减去">减去</h2>
<h2 id="划分">划分</h2>
<h1 id="component">Component</h1>
<h2 id="色相">色相</h2>
<h2 id="饱和度">饱和度</h2>
<h2 id="颜色">颜色</h2>
<h2 id="明度">明度</h2>
<h1 id="参考">参考</h1>
<ol>
<li>https://en.wikipedia.org/wiki/Blend_modes</li>
<li>https://photoshoptrainingchannel.com/blending-modes-explained/</li>
<li>https://docs.gimp.org/en/gimp-concepts-layer-modes.html</li>
<li>https://jingyan.baidu.com/article/36d6ed1f7c04801bcf4883c2.html</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[But How Do It Know-The Basic Principles of Computers]]></title>
        <id>https://ayosi1996.github.io/post/computer-principle/</id>
        <link href="https://ayosi1996.github.io/post/computer-principle/">
        </link>
        <updated>2020-01-10T14:49:44.000Z</updated>
        <summary type="html"><![CDATA[<p>《But How Do It Know-The Basic Principles of Computers》读书笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>《But How Do It Know-The Basic Principles of Computers》读书笔记</p>
<!-- more -->
<h1 id="just-a-little-bit">Just a Little Bit</h1>
<p>There is only one kind of thing in computer. It is called a bit.</p>
<p>A bit is always in one of its two possible states, either off or on, and they change between on and off when they are told to do so.<br>
A computer bit is just a place, if there is no electricity in that place,then the bit is off. When electricity is present, then the bit is on.</p>
<h1 id="the-most-basic-part">The most basic part</h1>
<p><img src="https://img-blog.csdnimg.cn/20200316231042403.png" alt="在这里插入图片描述" loading="lazy"><br>
This is the most basic part that computers are made of. It’s called NAND gate. NAND gate is a simple device that has three connections where there may or may not be some electricity.</p>
<p>This type of computer part is in fact the <strong>ONLY</strong>  type of part required to build a computer.</p>
<p>The two wires on the left (a and b) are the inputs where electricity may be put into the device, and the wire on the right (c) is the output where electricity may come out of the device.</p>
<p>The chart shows how the various input combinations create the output(0 means off, 1 means on) :<br>
<img src="https://img-blog.csdnimg.cn/20200316231149368.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="simple-variations">Simple Variations</h1>
<h2 id="not-gate">NOT gate:</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316231553620.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316231625454.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="and-gate">AND gate:</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316231714132.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316231735992.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="remember-when">Remember When</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200316231823632.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>The diagram shows one bit of computer memory.</p>
<p>‘I’ is where we input the bit that we want to remember, and ‘o’ is the output of the remembered bit. ‘S’ is an input that tells these gates when to ‘set’ the memory.</p>
<p>With ‘s’ on, ‘o’ does whatever ‘i’ does. With ‘s’ off, ‘o’ stays the way it and ‘i’ were, at the last instant just before ‘s’ went off. Now ‘i’ can change, but ‘o’ stays the way it was.</p>
<p>The chart can be simplified:<br>
<img src="https://img-blog.csdnimg.cn/20200316231503612.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="eight-is-enough">Eight Is Enough</h1>
<p>In order to be able to represent something more than simple yes/no matters, what we are going to do is to stack up eight bits in a single package, and use them as a single unit.</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200316231920677.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>When the single ‘s’ gets turned on and then off again, all eight of these ‘M’s will capture the states of their corresponding ‘i’s at the same time. This assembly has a name; it is called a byte. A byte can represent 256 states.</p>
<h1 id="codes">Codes</h1>
<p>Now that we have 256 possibilities. The first things that might fit the bill is written language. In order to “put” an ‘A’ into a byte, we will use a code to associate one of the possible states of the byte with something that exists in the real world.</p>
<p>The letter ‘A’ will be represented by a particular pattern of 1s and 0s in the bits of a byte.</p>
<p>The most commonly used code is ASCII (American Standard Code for Information Interchange).</p>
<center> PART OF ASCII CODE TABLE </center>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200316232009265.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="back-to-the-byte">Back to the Byte</h1>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200316232048311.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>These eight AND gates, together, are called an“Enabler.”  When ‘e’ is off, whatever comes into the Enabler goes no further. When ‘e’ is on, the inputs go through the Enabler unchanged to the outputs, ‘o.’</p>
<p>An Enabler allows a byte through when the bit ‘e’ is 1 and stops the byte when it is 0.</p>
<p>Register:</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200316232116835.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>Register simply means a place to record some kind of information, Every time you store a new state in a computer register, the previous state of the eight memory bits is lost. The only thing that is in there is the most recently saved value.</p>
<h1 id="the-magic-bus">The Magic Bus</h1>
<p>we can simplify, and replace it with one of these:<br>
<img src="https://img-blog.csdnimg.cn/20200316232249578.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img-blog.csdnimg.cn/20200316232312478.png" alt="在这里插入图片描述" loading="lazy"><br>
When there is a connection between two of these bundles of wires, one wire of each bundle is connected to one wire of the other bundle as shown in the diagram on the left.</p>
<p>This grouping of eight wires is so common inside computers that it has a name. It is called a bus.</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200316232329985.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>In the example, we have a bus, and there are five registers, each of which has both its input and output connected to the same bus.</p>
<p>All of the ‘s’ bits and ‘e’ bits are off. If you want to copy the information from R1 into R4, first you turn the ‘e’ bit of R1 on. The data in R1 will now be on the bus, and available at the inputs of all five registers. If you then briefly turn the ‘s’ bit of R4 on and back off, the data on the bus will be captured into R4.</p>
<p>So this is a bus. It is a bundle of eight wires that typically goes to many places.</p>
<h1 id="more-gate-combinations">More Gate Combinations</h1>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200316232404163.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>This combination is called a decoder.<br>
<br><br>
The name means that if you consider the four possible states of the two<br>
inputs as a code, then the output tells you which of the codes is currently on the input.</p>
<p>This can be extended. If we added a third input, there would then be eight possible input combinations.</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200316232511238.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2020031623253272.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="first-half-of-the-computer">First Half of the Computer</h1>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200316232603206.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>We start with a single register. A combination of bits is placed on the bus and the ‘sa’ (set a) bit goes 1 then 0. That bit pattern is now stored in this register. The first four output bits are connected to one 4X16 decoder, and the other four output bits are connected to another 4X16 decoder.<br>
<br><br>
Of these 256 intersections, there will be only one intersection where both the horizontal and vertical wires are on. Which intersection that is will change every time the value in R is changed.</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200316232627768.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>There is a circle on the diagram above, around one of the intersections of the grid.<br>
There is only one intersection where both grid wires are on. Therefore there is only one intersection has its ‘x’ gate on, and its register can be set from the bus, or its contents can be enabled onto the bus and sent elsewhere.</p>
<p>The above is the computer’s main memory. It is half of what is necessary to build a computer.</p>
<p>This is a good type of memory to use if you want to be able to access the bytes of memory in a random order. So this type of memory is called “Random Access Memory,” or “RAM”.</p>
<p>It uses 257 registers. 256 registers are memory storage locations, one register is used to select one of the storage locations and is called the “Memory Address Register” or “MAR”.</p>
<p>A larger RAM:<br>
<img src="https://img-blog.csdnimg.cn/2020031623271019.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200316232730713.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="number">Number</h1>
<p>The binary system</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200316232752942.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>In the binary system, each position is worth two times the amount to its right.</p>
<h1 id="the-other-half-of-the-computer">The Other Half of the Computer</h1>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200316232815529.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>We will call this half of the computer the “Central Processing Unit,” or CPU.</p>
<p>“Control Section” controls all of the ‘set’ and ‘enable’ bits in the CPU and the RAM.</p>
<p>R0, R1, R2, and R3 are registers that are used as short- term storage for bytes that are needed in the CPU.</p>
<p>The register called ‘TMP’ means temporary. Its input comes from the bus, and its output goes downward.</p>
<p>The last register is called the accumulator, or ACC.</p>
<h1 id="more-gate">More gate</h1>
<h2 id="or-gate">OR gate</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316232843199.png" alt="在这里插入图片描述" loading="lazy"><br>
simplified diagram:<br>
<img src="https://img-blog.csdnimg.cn/20200316232914377.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="xor-gate">XOR gate</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316232937186.png" alt="在这里插入图片描述" loading="lazy"><br>
simplified diagram:<br>
<img src="https://img-blog.csdnimg.cn/20200316232952425.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="bytes-operation">Bytes Operation</h1>
<h2 id="the-left-and-right-shifters">The Left and Right Shifters</h2>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200316233047247.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20200316233124875.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>This shows two registers connected by a right shifter. The one at the bottom (shift out) is often connected back to the one on the top (shift in).</p>
<h2 id="the-notter">The NOTter</h2>
<figure data-type="image" tabindex="17"><img src="https://img-blog.csdnimg.cn/20200316233152979.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://img-blog.csdnimg.cn/20200316233208114.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>This device connects two registers with eight NOT gates.<br>
Each bit will be changed to its opposite.</p>
<h2 id="the-ander">The ANDer</h2>
<figure data-type="image" tabindex="19"><img src="https://img-blog.csdnimg.cn/20200316233230887.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://img-blog.csdnimg.cn/2020031623325083.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="the-orer">The ORer</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316233316214.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316233334350.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="the-exclusive-orer">The Exclusive ORer</h2>
<p><img src="https://img-blog.csdnimg.cn/20200316233357447.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316233418354.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="the-adder">The Adder</h2>
<p>Adding three bits:<br>
<img src="https://img-blog.csdnimg.cn/20200316233442228.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316233501961.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>Adding two bytes:<br>
<img src="https://img-blog.csdnimg.cn/20200316233532480.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020031623355334.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="the-comparator-and-zero">The Comparator and Zero</h2>
<p>Here is one bit of the comparator:<br>
<img src="https://img-blog.csdnimg.cn/20200316233620232.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Gate 4 turns on if three things are true.</p>
<ol>
<li>Bits ‘a’ and ‘b’ are different.</li>
<li>Bit ‘a’ is the one that is on.</li>
<li>All bits above this point have been equal.</li>
</ol>
<p>Two bytes comparators:<br>
<img src="https://img-blog.csdnimg.cn/20200316233642266.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316233706761.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="the-arithmetic-and-logic-unit">The Arithmetic and Logic Unit</h1>
<p>We are going take all seven of these devices, put them together in one unit, and provide a method of selecting which one of these devices we want to use at any given time. This is called the “Arithmetic and Logic Unit,’ or “ALU”.</p>
<p><img src="https://img-blog.csdnimg.cn/20200316233728852.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316233750527.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="more-of-the-processor">More of the Processor</h1>
<p>There is one more little device we need:</p>
<figure data-type="image" tabindex="21"><img src="https://img-blog.csdnimg.cn/20200316233811781.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>When the ‘bus 1’ bit is off, all of the bits of the input bus pass through to the output bus unchanged. When the ‘bus 1’ bit is on, the input byte is ignored and the output byte will be 0000 0001.</p>
<p>The CPU diagram<br>
<img src="https://img-blog.csdnimg.cn/20200316233833407.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>For a two input ALU operation, there are two steps. First we enable one of the registers onto the bus and set it into TMP. Then we enable the second register onto the bus, choose the ALU operation, and set the answer into ACC.</p>
<h1 id="clock">Clock</h1>
<figure data-type="image" tabindex="22"><img src="https://img-blog.csdnimg.cn/20200316233900340.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>This graph shows bit ‘X’ going on and off, on and off regularly.  When something repeats some action regularly, one of those actions, individually, is called a cycle.</p>
<p>One Hertz (or Hz for short) means that the electricity is going on and off once per second.</p>
<figure data-type="image" tabindex="23"><img src="https://img-blog.csdnimg.cn/20200316234034697.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><img src="https://img-blog.csdnimg.cn/20200316234008320.png" alt="在这里插入图片描述" loading="lazy"><br>
This bit is called the clock. These days it is well over a billion times per second, or several gigahertz. This is one of the main characteristics that computer companies tell you about to show you how great their computers are.</p>
<figure data-type="image" tabindex="24"><img src="https://img-blog.csdnimg.cn/20200316234108941.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>'clk d' will delay the electricity about one quarter of a cycle.<br>
<img src="https://img-blog.csdnimg.cn/20200316234141181.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200316234156224.png" alt="在这里插入图片描述" loading="lazy"><br>
‘clk e,’ which stands for clock enable, and ‘clk s,’ which stands for clock set.</p>
<figure data-type="image" tabindex="25"><img src="https://img-blog.csdnimg.cn/20200316234222870.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>This meets our requirements of needing to first enable the output of a register, and then, after the data travel down the bus, to turn the set bit of the destination register on and off before turning the enable bit off at the first register.</p>
<figure data-type="image" tabindex="26"><img src="https://img-blog.csdnimg.cn/20200316234238399.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="doing-something-useful">Doing Something Useful</h1>
<p>Add R0 and R1 to R0:</p>
<ul>
<li>first clock cycle : enable R1 onto the bus, and set it into TMP.</li>
<li>second cycle : enable R0 onto the bus, set the ALU to ADD, and set the answer into ACC.</li>
<li>third cycle: enable ACC onto the bus, and set it into R0.</li>
</ul>
<h1 id="step-by-step">Step by Step</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记——渲染流水线]]></title>
        <id>https://ayosi1996.github.io/post/unity-shader-2/</id>
        <link href="https://ayosi1996.github.io/post/unity-shader-2/">
        </link>
        <updated>2019-08-30T14:28:32.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="概述">概述</h1>
<br>
渲染流水线的最终目的在于生成或者说是渲染一张二维图像，即我们在电脑屏幕上看到的所有效果。
]]></summary>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<br>
渲染流水线的最终目的在于生成或者说是渲染一张二维图像，即我们在电脑屏幕上看到的所有效果。
<!--more-->
<br>
渲染流程大体可以分为三个概念阶段：
<figure data-type="image" tabindex="1"><img src="https://ayosi1996.github.io/post-images/1584282752139.png" alt="" loading="lazy"></figure>
<h1 id="cpu流水线">CPU流水线</h1>
<ul>
<li><font size=5><b>应用阶段</b></font></li>
</ul>
<p>开发者具有这个阶段的绝对控制权。<br>
大致分为三个阶段：</p>
<ol>
<li><font color="#990500"><b>把数据加载到显存中</b></font></li>
</ol>
<p>渲染所需的数据从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据</p>
<figure data-type="image" tabindex="2"><img src="https://ayosi1996.github.io/post-images/1584282780490.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p><font color="#990500"><b>设置渲染状态</b></font><br>
渲染状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器/片元着色器、光源属性、材质等。</p>
</li>
<li>
<p><font color="#990500"><b>调用Draw Call</b></font><br>
Draw Call只是一个命令，从CPU发送向GPU。这个命令仅仅会指向一个需要被渲染的图元列表，并且不会包含任何材质信息。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://ayosi1996.github.io/post-images/1584282801923.png" alt="" loading="lazy"></figure>
<h1 id="gpu流水线">GPU流水线</h1>
<figure data-type="image" tabindex="4"><img src="https://ayosi1996.github.io/post-images/1584282981012.png" alt="" loading="lazy"></figure>
<center><font size = 2>GPU的渲染流水线实现。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的</font></center>
<p>GPU的渲染流水线接收顶点数据作为输入。这些顶点数据是由应用阶段加载到显存中，再由Draw Call指定的。</p>
<ul>
<li><font size=5><b>几何阶段</b></font></li>
</ul>
<p><font color="#990500"><b>顶点着色器</b></font>是完全可编程的，它的处理单位是顶点。顶点着色器需要完成的工作主要有：坐标变换、逐顶点光照和输出后续阶段所需的数据。必须完成的一个工作是，把顶点坐标从模型空间转换到齐次裁剪空间。</p>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzny3k85j30go05zwf6.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>顶点着色器会将模型顶点的位置变换到齐次裁剪坐标空间下，进行输出后再由硬件做透视除法得到NDC下的坐标 </font></center>
<br>
<font color="#990500"><b>裁剪</b></font>是为了不处理那些不在摄像机视野范围内的物体。这一步不可编程。裁剪过程:
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzoqxyilj30go04hjrt.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图元（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃  </font></center>
<br>
<font color="#990500"><b>屏幕映射</b></font>的任务是把每个图元的*x*和*y*坐标转换到屏幕坐标系下。
将*x、y *坐标从（-1,1）范围转换到屏幕坐标系中：
<figure data-type="image" tabindex="7"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzs2fd2wj30go05tjrq.jpg" alt="undefined" loading="lazy"></figure>
<p>注意：屏幕坐标系在OpenGL和DiretX之间存在差异：<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzsgrmajj30m808tt96.jpg" alt="undefined" loading="lazy"></p>
<ul>
<li><font size=5><b>光栅化阶段</b></font></li>
</ul>
<p><font color="#990500"><b>三角形设置</b></font>阶段会计算光栅化一个三角形网格所需的数据。</p>
<p><font color="#990500"><b>三角形遍历</b></font>阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖，会生成一个片元。片元是包含了很多状态的集合，这些状态包括屏幕坐标、深度信息、法线、纹理坐标等。三角形遍历过程：<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuztl36lgj30m80b60uo.jpg" alt="undefined" loading="lazy"></p>
<center><font size = 2>根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。  </font></center>
<br>
<font color="#990500"><b>片元着色器</b></font>是另一个非常重要的可编程着色器阶段。这一阶段可以完成很多重要的渲染技术，技术之一是纹理采样。在执行片元着色器时，它不能将自己的任何结果直接发送给它的邻居。这一阶段的输出是一个或多个颜色值。
<p><font color="#990500"><b>逐片元操作</b></font>这一阶段有几个主要任务：</p>
<ol>
<li>决定每个片元的可见性。涉及许多测试工作：深度测试、模板测试等。</li>
<li>如果片元通过测试，需要把源颜色(通过测试的片元颜色)与目标颜色(颜色缓冲区中的颜色)进行混合。<br>
<br><br>
<font size =3>此阶段所做的操作：</font><br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzupbpjnj30m802v3yv.jpg" alt="undefined" loading="lazy"></li>
</ol>
<center><font size = 2>只有通过了所有的测试后，新生成的片元才能和颜色缓冲区中已经存在的像素颜色进行混合，最后再写入颜色缓冲区中   </font></center>
<p><font size =3>模板测试和深度测试简化流程图：</font><br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzv2il54j30go0hignx.jpg" alt="undefined" loading="lazy"></p>
<p><font size =3>混合操作简化流程图：</font><br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzvifnuoj30go0iijsz.jpg" alt="undefined" loading="lazy"></p>
<p><font size =3>Unity的渲染流水线中，深度测试是在片元着色器之前。<br>屏幕显示的就是颜色缓冲区的值，为了避免看到正在进行光栅化的图元，GPU会使用双重缓冲：即对场景的渲染发生在后置缓冲中。</font></p>
<h1 id="draw-call">Draw Call</h1>
<p>Draw Call本身的含义很简单，就是CPU调用图像编程接口，如OpelGL中的glDrawElements命令。<br>
Draw Call中造成性能问题的元凶是CPU</p>
<p><font size=5><b>CPU和GPU实现并行工作</b></font></p>
<p>让CPU和GPU可以并行工作，解决方法是使用一个命令缓冲区：<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzwc6s1rj30dw0c0wfl.jpg" alt="undefined" loading="lazy"></p>
<center><font size = 2>CPU通过图像编程接口向命令缓冲区中添加命令，而GPU从中读取命令并执行。黄色方框内的命令就是Draw Call，而红色方框内的命令用于改变渲染状态。我们使用红色方框来表示改变渲染状态的命令，是因为这些命令往往更加耗时   </font></center>
<br>
<font size=5><b>Draw Call多了影响帧率</b></font>
<p>如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call上，造成CPU过载。<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuzwy53u9j30go0demzv.jpg" alt="undefined" loading="lazy"></p>
<center><font size = 2>命令缓冲区中的虚线方框表示GPU已经完成的命令。此时，命令缓冲区中没有可以执行的命令了，GPU处于空闲状态，而CPU还没有准备好下一个渲染命令。  </font></center>
<br>
<font size=5><b>减少Draw Call</b></font>
<ol>
<li>避免使用大量很小的网格。</li>
<li>避免使用过多的材质。</li>
</ol>
<p>以便于Unity中利用批处理进行优化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blender 2.79 BGE记录所有物体的动画]]></title>
        <id>https://ayosi1996.github.io/post/iqKqdD2bN/</id>
        <link href="https://ayosi1996.github.io/post/iqKqdD2bN/">
        </link>
        <updated>2019-08-16T22:25:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Blender 2.x的游戏引擎有个很好的功能就是记录动画，可惜的是只有刚体、软体、静态属性的物体能被记录，而且有子物体也不会被记录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Blender 2.x的游戏引擎有个很好的功能就是记录动画，可惜的是只有刚体、软体、静态属性的物体能被记录，而且有子物体也不会被记录。</p>
<!--more-->
<p>在搜索了很多资料后终于找到了一个简单满足我要求的一个小脚本。（下载链接在文末）</p>
<p>文件包含两个脚本：object2text.py 、text_to_keyframe.py</p>
<ol>
<li>object2text.py 主要功能是记录动画数据到csv文件<br>
主要变量：</li>
</ol>
<ul>
<li>target_object：需要记录动画的物体名字</li>
<li>rate:动画数据记录的速度</li>
<li>默认记录的csv文件位置是在Blender安装文件夹，想要改变保存位置需要修改 write_data()函数中的filename参数</li>
</ul>
<ol start="2">
<li>text_to_keyframe.py 主要功能是读取csv文件<br>
主要变量：</li>
</ol>
<ul>
<li>target_object:目标物体的名称</li>
<li>framerate:读取动画的速率</li>
<li>filename:csv文件的位置</li>
</ul>
<h1 id="使用方法">使用方法</h1>
<h2 id="保存动画数据">保存动画数据</h2>
<ol>
<li>添加Always（总是）传感器，并且命名为“recorder”</li>
<li>添加一个Python传感器，然后脚本选择 object2text.py</li>
<li>添加 游戏引擎 促动器，并且命名为“quit_game&quot;</li>
<li>在文本编辑器中打开 object2text.py ，修改'target_object'和'rate'变量</li>
<li>运行游戏记录动画数据，退出游戏一定要用Q键退出，否则数据不会被写入</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://ayosi1996.github.io/post-images/1584292910143.png" alt="" loading="lazy"></figure>
<h2 id="读取动画数据">读取动画数据</h2>
<p>需要注意的是当前该脚本只记录了位置和旋转数据</p>
<ol>
<li>打开 'text_to_keyframe.py' 脚本并且修改其中的变量，要与 object2text.py 中的变量设置相对应</li>
<li>运行脚本，然后播放动画</li>
</ol>
<h2 id="错误解决">错误解决</h2>
<p>在测试过程中发现，记录的csv文件中会有空行导致读取失败，解决方法是将 object2text.py 文件中的</p>
<pre><code>with open(filename, 'wt') as fout:
</code></pre>
<p>修改为：</p>
<pre><code>with open(filename, 'wt', newline='') as fout:
</code></pre>
<p>下载地址：<a href="http://leocorp.glivion.tech/workshop/1/download">记录动画脚本文件</a></p>
<p>参考地址：<a href="http://leocorp.glivion.tech/workshop">FROM BLENDER GAME TO ANIMATION</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记——一个顶点是怎么显示在屏幕上的]]></title>
        <id>https://ayosi1996.github.io/post/unity-shader-1/</id>
        <link href="https://ayosi1996.github.io/post/unity-shader-1/">
        </link>
        <updated>2019-08-01T08:03:11.000Z</updated>
        <summary type="html"><![CDATA[<p><font color = 0077BB size = 3><strong>《Unity Shader入门精要》-冯乐乐 第四章读书笔记</strong></font><br>
<font color = 0077BB size = 3><strong>作者博客：<a href="http://blog.csdn.net/candycat1992">http://blog.csdn.net/candycat1992</a></strong></font></p>
]]></summary>
        <content type="html"><![CDATA[<p><font color = 0077BB size = 3><strong>《Unity Shader入门精要》-冯乐乐 第四章读书笔记</strong></font><br>
<font color = 0077BB size = 3><strong>作者博客：<a href="http://blog.csdn.net/candycat1992">http://blog.csdn.net/candycat1992</a></strong></font></p>
<!--more-->
<h1 id="font-size7-color-0077bb开始font"><font size=7 color = 0077BB>开始</font></h1>
<p><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuohbeztwj30jg08x7bl.jpg" alt="undefined" loading="lazy"><center><font size = 2>妞妞的鼻子是怎么绘制到屏幕上的？</font></center></p>
<p>一些重要的空间变换</p>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuogtb22ij30go0fltb8.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>渲染流水线中顶点的空间变换过程</font></center>
<h1 id="font-color-0077bb模型空间font"><font color = 0077BB>模型空间</font></h1>
<p>模型空间，有时也被称为对象空间（object space）或局部空间（local space）。</p>
<p>每个模型都有自己独立的坐标空间，当它移动或者旋转的时候，模型空间也会跟着它移动和旋转。</p>
<p>Unity在模型空间中使用的是左手坐标系。模型空间的原点和坐标通常在建模软件中确定好的。</p>
<p>当导入Unity后，可以在顶点着色器中访问到模型的顶点信息。</p>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuojqiadaj30b408dgno.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>奶牛的模型空间，在模型空间中鼻子的坐标是(0,2,4,1)</font></center>
<h1 id="font-color-0077bb世界空间font"><font color = 0077BB>世界空间</font></h1>
<p>在Unity中最大的空间，使用的是左手坐标系。在Unity中我们可以通过调整Transform组件中的Position属性来改变模型的位置，<strong>这里的位置指的是相对于这个<font color =red>Transform的父节点（Parent）的模型坐标空间</font>中的原点定义的。</strong></p>
<p>如果一个Transform没有父节点，这个位置就是世界坐标系中的位置。<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuotwc2tkj30go0drn7e.jpg" alt="undefined" loading="lazy"><center><font size = 2>农场游戏中的世界空间。世界空间的原点被放置在农场的中心。左下角显示了妞妞在世界空间中所做的变换。</font></center></p>
<p>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。通常称作<strong>模型变换</strong></p>
<p>大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。</p>
<p>根据上图Transform组件的信息构建模型变换的变换矩阵：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200317153432293.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2020031715353596.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>现在可以用它进行模型变换</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200317153608304.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="font-color-0077bb观察空间font"><font color = 0077BB>观察空间</font></h1>
<p>观察空间也被称为摄像机空间。</p>
<p>在观察空间中，摄像机位于原点。Unity中观察空间的坐标轴：+x轴指向右方，+y轴指向上方，+z轴指向<font color=  red>摄像机的后方</font></p>
<p>观察空间中使用的是右手坐标系，这是符合OpenGL传统的。</p>
<p>注意：观察空间和屏幕空间是不同的。一个是三维，一个是二维。</p>
<p>现在，需要求出从世界空间变换到观察空间的变换矩阵。第一种方法：计算 观察空间的的三个坐标轴在世界空间下的表示</p>
<p>构建出从观察空间变换到世界空间的变换矩阵，再对该矩阵求逆。</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200317153724935.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1lvc2Vm,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<center><font size = 2>矩阵表示从坐标空间C转换到坐标空间P的变换矩阵，x<sub>c</sub>、y<sub>c</sub>、z<sub>c</sub>表示坐标空间C的三个坐标轴在坐标空间P下的矢量表示。O<sub>c</sub>表示原点</font></center>
<p>第二种方法：想象平移整个观察空间，让摄像机位于世界坐标的原点，坐标轴与世界空间的坐标轴对齐（除了z轴，z轴相反）</p>
<p>按照第二种方法，由前面图片的Transform组件，进行逆向变换：将摄像机先按（0，-10,10）平移，回到原点，再按（-30,0,0）旋转，坐标轴对齐。即可求得变换矩阵 <strong>M</strong><sub>view</sub></p>
<p><strong>世界空间-&gt;观察空间</strong></p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200317153821626.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><font size=6 color = 0077BB><strong>裁剪空间</strong></font><br>
<br><br>
裁剪空间也被称为齐次裁剪空间。使用裁剪矩阵（clip matrix）或者叫做投影矩阵（projection matrix）进行顶点变换。裁剪空间的目标是能都方便地对渲染图元进行裁剪：视锥体内的图元被保留，视锥体外的图元被剔除，视锥体相交的图元会被裁剪。</p>
<p>视锥体有两种类型，这涉及到两种投影类型：透视投影、正交投影。</p>
<figure data-type="image" tabindex="8"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuoy65s86j30m80997cd.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>视锥体和裁剪平面。左侧是透视投影的视锥体，右侧是正交投影的视锥体</font></center>
<p>对于透视投影的视锥体来说，想要判断一个顶点是否处于内部是比较麻烦的。因此通过一个投影矩阵把顶点转换到一个裁剪空间中进行裁剪工作。</p>
<p>投影矩阵有两个目的：</p>
<p>首先是为投影做准备。虽然投影矩阵包含了投影二字，但是并没有真正的进行投影工作。真正的投影发生在后面的齐次除法过程中。</p>
<p>其次是对x，y，z分量进行缩放。直接使用视锥体的6个裁剪平面来进行裁剪会比较麻烦。经过投影矩阵的缩放后，可以直接使用w分量作为阈值，如果x，y，z分量都位于这个阈值内，就说明位于裁剪空间内。</p>
<p><strong><font size  = 4 color = #0077BB>透视投影：</font></strong><br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuoxuvx9kj30go0gnabn.jpg" alt="undefined" loading="lazy"></p>
<center><font size = 2>透视摄像机的参数对透视投影视锥体的影响 </font></center>
<figure data-type="image" tabindex="9"><img src="http://ww1.sinaimg.cn/large/005SUDKAgy1gcupcf1d9tj30rs0d7gos.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2> 在透视投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化 </font></center>
<p><strong><font size  = 4 color = #0077BB>正交投影：</font></strong></p>
<figure data-type="image" tabindex="10"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuox8hdvyj30dw0bbgm9.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>正交摄像机的参数对正交投影视锥体的影响  </font></center>
<figure data-type="image" tabindex="11"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuowytzzjj30rs0dijup.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化   </font></center>
<p>经过变换后，如果一个顶点在视锥体内，那么它变换后的坐标必须满足：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200317153919421.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>任何不满足上述条件的图元都需要被剔除或者裁剪。</p>
<h1 id="font-color-0077bb屏幕空间font"><font color = #0077BB>屏幕空间</font></h1>
<p>经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有裁剪工作后，就需要进行真正的投影了：我们需要把视锥体投影到屏幕空间中。经过这一步变换，我们会得到真正的像素位置。</p>
<p>这一步将顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可以理解成两个步骤：</p>
<p>首先进行标准齐次除法(homogenous division)，也称为透视除法。这个步骤就是用齐次坐标系的w分量去除以x、y、z分量。在OpenGL中，我们把这一步得到的坐标叫做归一化的设备坐标（Normalized Device Coordinates，NDC）。</p>
<p>经过透视投影变换后的裁剪空间，经过齐次除法后会变换到一个立方体内。</p>
<figure data-type="image" tabindex="13"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuowkvp2sj30rs0dlwhu.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>经过齐次除法后，透视投影的裁剪空间会变换到一个立方体 </font></center>
<figure data-type="image" tabindex="14"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuow7k3fcj30rs0d1ju1.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>经过齐次除法后，正交投影的裁剪空间会变换到一个立方体  </font></center>
<p>注意：按照OpenGL的传统，这个立方体x、y、z分量的范围都是[-1,1]。但在DirectX这样的API中，z分量的范围是[0,1]。Unity使用的是OpenGL的齐次裁剪空间</p>
<p>经过齐次除法后，透视投影和正交投影的视锥体都变换到一个相同的立方体内。现在可以根据变换后的x和y坐标来映射输出窗口的对应像素坐标。</p>
<p>在Unity中，屏幕空间左下角的像素坐标是（0,0）右上角的像素坐标是（pixelWidth,pixelHeight）。</p>
<p>齐次除法和屏幕映射的过程可以使用下面的公式来总结：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200317153948343.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>对于z分量，通常用于深度缓冲。一个传统的方式是把 clip<sub>z</sub>/clip<sub>w</sub>的值直接存进深度缓冲中。</p>
<p>在Unity中，从裁剪空间到屏幕空间的转换是由底层帮我们完成的。顶点着色器只要把顶点转换到裁剪空间即可。</p>
<hr>
<p>以上就是一个顶点从模型空间变换到屏幕坐标的过程。</p>
<figure data-type="image" tabindex="16"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuovrolyyj30go0fltb8.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>渲染流水线中顶点的空间变换过程  </font></center>
<figure data-type="image" tabindex="17"><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcuouvo2uij308c0hhjt7.jpg" alt="undefined" loading="lazy"></figure>
<center><font size = 2>Unity中各个坐标空间的旋向性 </font></center>
<h1 id="font-size7-color-0077bb完font"><font size=7 color = #0077BB>完</font></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shader中常用的光照模型]]></title>
        <id>https://ayosi1996.github.io/post/shader-light-model-2/</id>
        <link href="https://ayosi1996.github.io/post/shader-light-model-2/">
        </link>
        <updated>2019-07-04T23:31:26.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h1 id="font-size-6-color-0077bb光照模型font"><font size =6 color = 0077bb>光照模型</font></h1>
<h2 id="font-color-990500lambertfont"><font color = 990500>Lambert</font></h2>
<p>粗糙的物体表面向各个方向等强度的反射光，这种等同地向各个方向散射的现象称为光的漫反射（diffuse reflection）。漫反射符合兰伯特定律（Lambert's law）：反射光线的强度与表面法线和光源方向之间的夹角成正比。这是一种理想的漫反射模型，也被称为兰伯特光照模型。</p>
<ul>
<li>漫反射：</li>
<li></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200317154053318.png" alt="在这里插入图片描述" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200317154127252.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h2 id="font-color-990500half-lambertfont"><font color = 990500>Half Lambert</font></h2>
<p>使用Lambert漫反射光照模型有一个缺点：背光面明暗一样，看起来想一个平面一样，失去了模型细节。于是一种改善的技术提了出来：半兰伯特（Half Lambert）光照模型。</p>
<ul>
<li>广义的半兰伯特光照模型公式：</li>
<li></li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200317154150148.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>绝大多是情况下a和b的值均为0.5。</p>
<h2 id="font-color-990500phongfont"><font color = 990500>Phong</font></h2>
<p>早期的游戏引擎中往往只有一个光照模型，就是<strong>标准光照模型</strong>。标准光照模型只关心直接光照，也就是那些直接从光源发射出来照射到物体表面后经过物体表面的一次反射直接进入摄像机的光线。</p>
<p>因为裴祥风（Bui Tuong Phong）首先提出了使用漫反射和高光反射的和来对反射光照进行建模的基本思想，并且<strong>提出了基于经验的计算高光反射的方法</strong>。所以标准光照模型也被称为<strong>Phong光照模型</strong>。</p>
<p>它的计算方法是，把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度：</p>
<ul>
<li><strong>自发光（emissive）</strong>，用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200317154211691.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><b>m<sub>emissive</sub></b>是材质的自发光颜色。</p>
<ul>
<li><strong>高光反射（specular）</strong>，用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcv31db0jvj30dw06d74v.jpg" alt="undefined" loading="lazy"><center><font size=2>使用Phong模型计算高光反射, <a href="http://candycat1992.github.io/unity_shaders_book/unity_shaders_book_images.html">图片来源</a></font></center></p>
<p>计算公式：</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200317154254458.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>这就是<strong>Phong提出的基于经验的高光反射模型</strong>。其中：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{light}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：入射光线的颜色和强度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{specular}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：材质的高光反射颜色，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>:视角方向（指向摄像机） ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>:光线反射方向，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>g</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{gloss}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：材质的光泽度（gloss），也被称为反光度（shiness）。<br>
<br>反射方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>计算方法：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200317154327630.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>
<p><strong>漫反射（diffuse）</strong>，用于描述当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。<br>
即上面的Lambert定律：<br>
<img src="https://img-blog.csdnimg.cn/20200317154401433.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p><strong>环境光（ambient）</strong>，用于描述其他所有的间接光照。</p>
</li>
<li></li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200317154420827.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>环境光<b>g<sub>ambient</sub></b>通常是一个全局变量，即场景中的所有物体都使用了这个环境光。</p>
<h2 id="font-color-990500blinn-phongfont"><font color = 990500>Blinn Phong</font></h2>
<p>Blinn提出了一个简单的修改方法来得到与Phong高光反射模型类似的效果，它的基本思想是，避免计算反射方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>。Blinn模型引入了一个新的矢量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>h</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>。计算方法为：<br>
<img src="https://img-blog.csdnimg.cn/20200317154448174.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>然后使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>n</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>h</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>之间的夹角进行计算，而非<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.17994em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>之间的夹角。</p>
<p><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcv31udmd7j30dw06d3z4.jpg" alt="undefined" loading="lazy"><center><font size=2>Blinn模型 <a href="http://candycat1992.github.io/unity_shaders_book/unity_shaders_book_images.html">图片来源</a></font></center></p>
<p><strong>Blinn模型</strong>的公式：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200317154509471.png" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blender IK FK Snap]]></title>
        <id>https://ayosi1996.github.io/post/CU6ZQD3BL/</id>
        <link href="https://ayosi1996.github.io/post/CU6ZQD3BL/">
        </link>
        <updated>2019-06-15T05:32:27.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>IK/FK Snap是一个很实用的功能，rigify插件自带此功能，但是对于已经设置好的自定义rig就没办法使用了，所以在网上找了一个相当简易的IK/FK Snap脚本：<br>
https://gist.github.com/dskjal/76a778b4ad00e5fd8e20b6a1e104676c</p>
<p>由于脚本中的骨骼名称已经全部定义好了，所以使用时还需要按照脚本修改骨骼名称。为了方便使用，我对脚本做了些修改。</p>
<p>修改后的结果：<br>
<img src="https://ayosi1996.github.io/post-images/1584293385503.png" alt="" loading="lazy"></p>
<p>主要就是支持自己选择骨骼了。</p>
<p>使用方法：<br>
当选中一个骨架时，按照名称选择对应的骨骼，然后再进行IK-&gt;FK 或者 FK-&gt;IK</p>
<p>一般胳膊骨骼控制需要用到3组骨骼：形变骨骼、IK控制、FK控制，所以该功能一般配合IK/FK Switch来使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blender 2D图片转为3D模型并绑定骨骼]]></title>
        <id>https://ayosi1996.github.io/post/SUwH35hRk/</id>
        <link href="https://ayosi1996.github.io/post/SUwH35hRk/">
        </link>
        <updated>2019-05-30T08:22:38.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h2 id="最终效果演示">最终效果演示：</h2>
<figure data-type="image" tabindex="1"><img src="https://ayosi1996.github.io/post-images/1584293048573.gif" alt="" loading="lazy"></figure>
<h2 id="原始图片">原始图片：</h2>
<figure data-type="image" tabindex="2"><img src="https://ayosi1996.github.io/post-images/1584293062377.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="生成网格"><strong>生成网格</strong></h2>
<ul>
<li>
<p>使用Images as Planes导入Tracer-Tpose.png</p>
</li>
<li>
<p>将生成的Planes细分多次，然后删除多余的顶点（大概形状就行）<br>
<img src="https://ayosi1996.github.io/post-images/1584293071593.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="绑定骨骼"><strong>绑定骨骼</strong></h2>
<ul>
<li>
<p>Shift+A 新建Basic Human Armature</p>
</li>
<li>
<p>将骨架与模型位置匹配<br>
<img src="https://ayosi1996.github.io/post-images/1584293078089.png" alt="" loading="lazy"></p>
</li>
<li>
<p>在Object Mode依次选中2D模型和骨架，然后按Ctrl+P，选自动权重</p>
</li>
<li>
<p>绑定完成</p>
</li>
</ul>
<h2 id="动作绑定"><strong>动作绑定</strong></h2>
<ul>
<li>Blender导出FBX，不导出灯光和相机</li>
<li>在Mixamo中绑定动作</li>
<li>下载绑定动作后的FBX</li>
</ul>
<h2 id="材质贴图"><strong>材质贴图</strong></h2>
<ul>
<li>导入FBX到Blender</li>
<li>编辑Shading node(EEVEE渲染需要将Material Blend Mode改为Alpha Blend/Hashed)<br>
<img src="https://ayosi1996.github.io/post-images/1584293085104.png" alt="" loading="lazy"><center><img src="Blender2DTo3D/shading-node.png" alt="" loading="lazy"></center></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader基础入门]]></title>
        <id>https://ayosi1996.github.io/post/vDhd-ksEv/</id>
        <link href="https://ayosi1996.github.io/post/vDhd-ksEv/">
        </link>
        <updated>2019-04-12T00:47:46.000Z</updated>
        <summary type="html"><![CDATA[<p>Shader即着色器，是一款运行在GPU上的程序，用来对三维物体进行着色处理、光与影的计算、纹理颜色的呈现等，从而将游戏引擎中的一个个作为抽象的几何数据存在的模型、场景和特效，以和真实世界类似的光与影的形式呈现在玩家的眼中。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Shader即着色器，是一款运行在GPU上的程序，用来对三维物体进行着色处理、光与影的计算、纹理颜色的呈现等，从而将游戏引擎中的一个个作为抽象的几何数据存在的模型、场景和特效，以和真实世界类似的光与影的形式呈现在玩家的眼中。</p>
<!--more-->
<h1 id="font-color-0077bb-size-7开始font"><font color = #0077BB size =7>开始</font></h1>
<h2 id="font-color-0077bbshader是什么font"><font color = #0077BB>Shader是什么</font></h2>
<p>Shader即着色器，是一款运行在GPU上的程序，用来对三维物体进行着色处理、光与影的计算、纹理颜色的呈现等，从而将游戏引擎中的一个个作为抽象的几何数据存在的模型、场景和特效，以和真实世界类似的光与影的形式呈现在玩家的眼中。<br>
着色器用于图形处理器（GPU）的可编程流水线。渲染流水线可查看<a href="http://blog.csdn.net/macyosef/article/details/79029146">这篇读书笔记</a>。可编程流水线还能处理所有像素、顶点、纹理的位置、色调、饱和度、明度、对比度并实时地绘制图像。着色器还能产生如模糊、高光、有体积光源、失焦、卡通渲染、色调分离、畸变、凹凸贴图、边缘检测、运动检测等效果。</p>
<h2 id="font-color-0077bb一些概念font"><font color = #0077BB>一些概念</font></h2>
<p><strong><font color = #990500>材质(Material)</font></strong><br>
Shader负责将输入的Mesh（网格）以指定的方式和输入的贴图或者颜色等组合作用，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定的参数设置，将这些内容（Shader及输入参数）打包存储在一起，得到的就是一个Material（材质）。</p>
<p><strong><font color = #990500>纹理(Texture)</font></strong><br>
又称纹理贴图，在计算机图形学中是把存储在内存里的位图包裹到3D渲染物体的表面。纹理贴图给物体提供了丰富的细节，用简单的方式模拟出了复杂的外观。一个图像（纹理）被贴(映射)到场景中的一个简单形体上，就像印花贴到一个平面上一样。这大大减少了在场景中制作形体和纹理的计算量。<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcv3dweifkj32bl11iaev.jpg" alt="undefined" loading="lazy"><center><font size =2>1: 未加纹理贴图的球体, 2: 纹理贴图加凹凸贴图, 3: 仅凹凸贴图, 4: 透明图加纹理贴图 图片来源于wiki</font></center></p>
<p><strong><font color = #990500>纹理坐标</font></strong><br>
模型上面的贴图是通过纹理映射技术将其附加在模型上面，美术人员利用Max等工具建模时，会在建模软件中利用纹理展开技术把纹理映射坐标存储在每个顶点上，纹理映射坐标定义了该顶点在纹理中对应的2D坐标。这些坐标使用一个二维变量（u，v）来表示，纹理映射坐标也称为UV坐标。顶点UV坐标的范围通常都被归一化到[0,1]范围内。</p>
<p><strong><font color = #990500>纹理采样</font></strong></p>
<p><strong><font color = #990500>顶点和片元</font></strong><br>
顶点即模型中原始的顶点，一个顶点可以包含位置、颜色、法线、切线等数据。图元是由几何顶点组合而成，例如点、线段、多边形。片元是图元经过裁剪、转换窗口坐标、光栅化等一系列步骤后得来，<strong>需要注意的是，一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了屏幕坐标、深度信息、以及从几何阶段输出的法线、纹理坐标等。</strong><br>
显示在屏幕上的顶点经过的变换：<a href="http://blog.csdn.net/macyosef/article/details/79176471">一个顶点是怎么显示在屏幕上的</a></p>
<p><strong><font color = #990500>渲染路径</font></strong><br>
Rendering Path其实指的就是渲染场景中光照的方式。由于场景中的光源可能很多，甚至是动态的光源。所以怎么在速度和效果上达到一个最好的结果确实很困难。以当今的显卡发展为契机，人们才衍生出了这么多的Rendering Path来处理各种光照。<br>
<a href="http://www.cnblogs.com/polobymulberry/p/5126892.html?utm_source=tuicool&amp;utm_medium=referral">详细了解Rendering Path</a></p>
<h1 id="font-color-0077bb-size-7进阶font"><font color = #0077BB size =7>进阶</font></h1>
<h2 id="font-color-0077bbunity中的shaderfont"><font color = #0077BB>Unity中的Shader</font></h2>
<p>在Unity中，在<em>Project</em>视图中右击-&gt;<em>Create</em>-&gt;<em>Shader</em>能够创建一下集几种Shader</p>
<p><img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcv3ed3rvrj30fn094js7.jpg" alt="undefined" loading="lazy"><center><font size =2>unity版本：5.5.0f3</font></center><br>
<strong>Standard Surface Shader</strong> 会产生一个包含了标准光照模型（使用了Unity中新加的基于物理的渲染方法）的表面着色器。<br>
<strong>Unity Shader</strong> 会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。<br>
<strong>Image Effect Shader</strong> 则为我们实现各种屏幕后效果提供了一个基本模板。<br>
<strong>Compute Shader</strong> 会产生一种特殊的Shader文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。</p>
<h2 id="font-color-0077bbsurface-shader表面着色器font"><font color = #0077BB>Surface Shader（表面着色器）</font></h2>
<p>着色器基础结构：</p>
<pre><code>Shader &quot;Custom/MyShader&quot; {
	Properties {
		//属性
	}
	
	SubShader {
		//显卡A使用的Shader
	}
	
	SubShader {
		//显卡B使用的Shader
	}
	....
	//回滚
	FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><em>Properties</em> 语义块中包含了一系列属性，这些属性将会出现在材质面板中。</p>
<pre><code>Properties {
		Name(&quot;显示在面板的名字&quot;,属性类型) = DefaultValue
		Name(&quot;显示在面板的名字&quot;,属性类型) = DefaultValue
		//...
	}
</code></pre>
<p>属性类型（PropertyType）包括：Int,Float,Range(min,max),Color,Vector,2D,Cube,3D</p>
<p>Unity Shader可以包含多个<em>SubShader</em>语义块，至少一个。提供这种语义的原因是因为不同的显卡有不同的能力，在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass（Unity Shader中的顶点/片元着色器）。</p>
<p>下面是Unity中创建的默认Surface Shader：</p>
<pre><code>Shader &quot;Custom/MyShader&quot; {
	Properties {
		_Color (&quot;Color&quot;, Color) = (1,1,1,1)
		_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
		_Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5
		_Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0
	}
	SubShader {
		Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
		LOD 200
		
		CGPROGRAM
		// Physically based Standard lighting model, and enable shadows on all light types
		#pragma surface surf Standard fullforwardshadows

		// Use shader model 3.0 target, to get nicer looking lighting
		#pragma target 3.0

		sampler2D _MainTex;

		struct Input {
			float2 uv_MainTex;
		};

		half _Glossiness;
		half _Metallic;
		fixed4 _Color;

		void surf (Input IN, inout SurfaceOutputStandard o) {
			// Albedo comes from a texture tinted by color
			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
			o.Albedo = c.rgb;
			// Metallic and smoothness come from slider variables
			o.Metallic = _Metallic;
			o.Smoothness = _Glossiness;
			o.Alpha = c.a;
		}
		ENDCG
	}
	FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><strong><font color = "#990500">MyShader详解：</font></strong></p>
<p><font size=5>Properties</font><br>
<em>Properties</em>即定义的属性。在材质面板中如下图所示：<br>
<img src="http://ww1.sinaimg.cn/large/005SUDKAly1gcv3esm06xj30aa06z0t1.jpg" alt="undefined" loading="lazy"><br>
<font size=5>SubShader</font><br>
然后是<em>SubShader</em>，<em>SubShader</em>语义块中包含的定义通常如下：</p>
<pre><code>SubShader{
	//可选的标签
	[Tags]

    //可选的状态
    [RenderSetup]
    
    //顶点/片元着色器
    Pass{
    }
    //Other Passses
   }
</code></pre>
<p><font size=5>Tags</font><br>
SubShader的标签是一个键值对，并且都是字符串类型。这些键值对是SubShader和渲染引擎之间沟通的桥梁。用来告诉Unity怎样以及何时渲染这个对象物体。<br>
标签的结构：</p>
<pre><code>Tags{&quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; }
</code></pre>
<center>**SubShader的标签类型**</center>
<table>
<thead>
<tr>
<th style="text-align:center">标签类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Queue</td>
<td style="text-align:center">控制渲染顺序，指定该物体的渲染队列，可以使用自定义的渲染队列控制渲染顺序。</td>
</tr>
<tr>
<td style="text-align:center">RenderType</td>
<td style="text-align:center">对着色器进行分类，例如这是一个不透明或者透明的着色器</td>
</tr>
<tr>
<td style="text-align:center">DisableBatching</td>
<td style="text-align:center">指明是否对该<em>SubShader</em>使用批处理</td>
</tr>
<tr>
<td style="text-align:center">ForceNoShadowCasting</td>
<td style="text-align:center">控制使用该<em>SubShader</em>的物体是否会投射阴影。</td>
</tr>
<tr>
<td style="text-align:center">IgnoreProjector</td>
<td style="text-align:center">控制使用该<em>SubShader</em>的物体是否受Projector的影响。通常用于半透明物体</td>
</tr>
<tr>
<td style="text-align:center">CanUseSpriteAtlas</td>
<td style="text-align:center">当该<em>SubShader</em>用于精灵（Sprites）时，将该标签设置为False。</td>
</tr>
<tr>
<td style="text-align:center">PreviewType</td>
<td style="text-align:center">指明材质面板将如何预览该材质。默认为球形，可以设置为&quot;Plane&quot;,&quot;SkyBox&quot;。</td>
</tr>
</tbody>
</table>
<p><font size=5>状态</font></p>
<p>ShaderLab提供了一系列渲染状态的设置指令。</p>
<center>**常见的渲染状态设置选项**</center>
<table>
<thead>
<tr>
<th style="text-align:center">状态名称</th>
<th style="text-align:center">设置指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cull</td>
<td style="text-align:center">Cull Back/Front/Off</td>
<td style="text-align:center">设置剔除模式：剔除背面/正面/关闭剔除</td>
</tr>
<tr>
<td style="text-align:center">ZTest</td>
<td style="text-align:center">ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always</td>
<td style="text-align:center">设置深度测试时使用的函数</td>
</tr>
<tr>
<td style="text-align:center">ZWrite</td>
<td style="text-align:center">ZWrite On/Off</td>
<td style="text-align:center">开启/关闭深度写入</td>
</tr>
<tr>
<td style="text-align:center">Blend</td>
<td style="text-align:center">Blend SrcFactor DstFactor</td>
<td style="text-align:center">开启并设置混合模式</td>
</tr>
</tbody>
</table>
<p>当在<em>SubShader</em>块中设置了渲染状态时，将会应用到所有<em>Pass</em>。也可以在<em>Pass</em>块中单独设置渲染状态。</p>
<p><font size=5>LOD</font><br>
LOD即Level of Detail的缩写。是一种控制细节级别的技术。</p>
<p>在脚本中，我们可以用 <code>Shader.globalMaximumLOD = 100</code> 来全局设置 LOD值，激活使用相对应的 SubShader。<br>
也可以在<em>Edit</em>-&gt;<em>Project</em> <em>Setting</em>-&gt;<em>Quality</em> 中设置<em>Maximum LOD Level</em>设置最大LOD等级。</p>
<p><strong>Shader的LOD值小于所设定的LOD值，才会被编译使用。</strong> <em>Maximum LOD Level</em>的等级可以设置7个级别，例如设置为1，则表示把最大LOD值设置为100，等级2，则最大LOD值为200，以此类推，若设置为0，则表示不进行LOD判断，任何LOD值的Shader都会被使用。</p>
<p>根据这个特性，我们就可以在一个 Shader 里写一出组 SubShader ，分别设置不同的 LOD ，LOD 越大对应更好的效果并且要求更好的显卡性能。然后我们就可以用设置 LOD 的方法来控制游戏画面的渲染质量。</p>
<p><font size=5>主体</font></p>
<pre><code>//Shader的主体部分
CGPROGRAM
、、、
ENDCG
</code></pre>
<p>使用<em>CGPROGRAM</em>表示使用Cg/HLSL编写Shader代码。<br>
如果使用GLSL编写则需要嵌套在<em>GLSLPROGRAM</em>和<em>ENDGLSL</em>之间</p>
<pre><code>// Physically based Standard lighting model, and enable shadows on all light types
#pragma surface surf Standard fullforwardshadows
</code></pre>
<p>这是一据编译指令，它的格式如下：</p>
<pre><code>#pragma surface surfaceFunction lightModel [optionalparams]
</code></pre>
<ul>
<li>surface 表示声明的是一个表面着色器</li>
<li>surfaceFunction 表示着色器代码的方法的名字</li>
<li>lightModel  使用的光照模型</li>
<li>optionalparams 其他可选的编译指令</li>
</ul>
<p>所以上面的代码表示：着色器代码的方法的名字是<code>surf( ){ }</code>使用的光照模型是基于物理的标准光照模型，fullforwardshadows表示在所有灯光类型启用阴影在Forward渲染路径中。</p>
<p>更多的编译指令可以看<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html">这里</a></p>
<pre><code>// Use shader model 3.0 target, to get nicer looking lighting
#pragma target 3.0
</code></pre>
<p>这个编译指令表示定义Shader模型为Shader Model 3.0,</p>
<pre><code>sampler2D _MainTex;
half _Glossiness;
half _Metallic;
fixed4 _Color;
</code></pre>
<p>这是CG程序中的属性声明。可以发现这些变量与上面的属性名称是一样的。<br>
原因是这个Shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab；而现在我们是在<em>CGPROGRAM...ENDCG</em>这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在<em>Properties</em>中所定义的变量的话，必须使用和之前变量相同的名字进行声明。于是其实<code>sampler2D _MainTex;</code>做的事情就是再次声明并链接了<code>_MainTex</code>，使得接下来的CG程序能够使用这个变量。</p>
<pre><code class="language-c">//结构体
struct Input {
			float2 uv_MainTex;
		};
</code></pre>
<p>这里声明一个结构体，在后面作为着色器函数的输入。<br>
在CG程序中，在一个贴图变量（例子中是_MainTex）之前加上uv两个字母，就代表提取它的uv值（其实就是两个代表贴图上点的二维坐标 ）。我们之后就可以在surf程序中直接通过访问uv_MainTex来取得这张贴图当前需要计算的点的坐标值了。</p>
<pre><code class="language-c">void surf (Input IN, inout SurfaceOutputStandard o) {
		// Albedo comes from a texture tinted by color
		fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
		o.Albedo = c.rgb;
		// Metallic and smoothness come from slider variables
		o.Metallic = _Metallic;
		o.Smoothness = _Glossiness;
		o.Alpha = c.a;
	}
</code></pre>
<p>这里即着色器的方法部分了。<br>
<code>SurfaceOutputStandard</code>是预定义的输出结构，surf函数的目标就是根据输入把这个输出结构填上。<br>
<code>SurfaceOutputStandard</code>结构体的定义如下:</p>
<pre><code>struct SurfaceOutputStandard
{
    fixed3 Albedo;      // base (diffuse or specular) color
    fixed3 Normal;      // tangent space normal, if written
    half3 Emission;
    half Metallic;      // 0=non-metal, 1=metal
    half Smoothness;    // 0=rough, 1=smooth
    half Occlusion;     // occlusion (default 1)
    fixed Alpha;        // alpha for transparencies
};
</code></pre>
<p><font size=5>回滚</font></p>
<pre><code>FallBack &quot;Diffuse&quot;
</code></pre>
<p>这个指令用于告诉Unity，如果上面所有的SubShader在这块显卡上都不能运行，就用这个最低级的Shader。<br>
也可以<code>FallBack Off</code>直接关闭回滚功能。</p>
<h2 id="font-color-0077bbvertexfragment-shader顶点片元着色器font"><font color = #0077BB>Vertex/Fragment Shader（顶点/片元着色器）</font></h2>
<p>在Unity中通过在项目视图右键 <em>Create</em>-&gt;<em>Shader</em>-&gt;<em>Unity Shader</em>可以创建一个默认的顶点/片元着色器</p>
<pre><code>Shader &quot;Unlit/VertFragShader&quot;
{
	Properties
	{
		_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
	}
	SubShader
	{
		Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
		LOD 100

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			// make fog work
			#pragma multi_compile_fog
			
			#include &quot;UnityCG.cginc&quot;

			struct appdata
			{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;
				UNITY_FOG_COORDS(1)
				float4 vertex : SV_POSITION;
			};

			sampler2D _MainTex;
			float4 _MainTex_ST;
			
			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				UNITY_TRANSFER_FOG(o,o.vertex);
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				// sample the texture
				fixed4 col = tex2D(_MainTex, i.uv);
				// apply fog
				UNITY_APPLY_FOG(i.fogCoord, col);
				return col;
			}
			ENDCG
		}
	}
}
</code></pre>
<pre><code>#pragma vertex vert
#pragma fragment frag
</code></pre>
<p>这段编译指令分别指定顶点着色器和片元着色器对应的方法名<code>vert</code>和<code>frag</code></p>
<pre><code>#include &quot;UnityCG.cginc&quot;
</code></pre>
<p>为了方便开发者的编码过程，Unity'提供了很多内置文件，这些文件包含了很多提前定义的函数、变量、宏等。我们可以使用#include指令把这些文件包含进来，就可以使用Unity为我们提供的一些非常有用的变量和帮助函数。</p>
<pre><code class="language-c">struct appdata
			{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
			};
</code></pre>
<p>这里使用一个结构体来定义顶点着色器的输入，问了创建一个自定义的结构体，我们必须使用如下格式来定义它：</p>
<pre><code>struct StructName{
	Type Name : Semantic;
	Type Name : Semantic;
	......
};
</code></pre>
<p>Unity支持的语义(Semantic)有<br>
<em>POSITION,TANGENT,NORMAL,TEXCOORD0,TEXCOORD1,TEXCOORD2,TEXCOORD3,COLOR</em>等。<br>
上面代码的<em>POSITION</em>语义表示用模型空间的顶点坐标填充vertex变量，<em>TEXCOORD0</em>表示用模型的第一套纹理坐标填充texcoord变量。</p>
<pre><code>struct v2f
		{
			float2 uv : TEXCOORD0;
			UNITY_FOG_COORDS(1)
			float4 vertex : SV_POSITION;
		};
</code></pre>
<p>这个结构体用于在顶点着色器和片元着色器之前传递信息，所以一般叫做v2f(vert to frag)。<br>
<em>SV_POSITION</em>表示顶点着色器的输出是裁剪空间的顶点坐标。</p>
<p>需要注意的是表面着色器（Surface Shader）本质上也是顶点/片元着色器。在提供给Unity一个表面着色器时，它会在背后转换为比较复杂的顶点/片元着色器。</p>
<hr>
<h1 id="font-color-0077bb-size-7参考font"><font color = #0077BB size =7>参考</font></h1>
<p>[1] 《Unity Shader入门精要》.冯乐乐<br>
[2] 《ShaderLab开发实战详解》.郭浩瑜<br>
[3]  https://onevcat.com/2013/07/shader-tutorial-1/<br>
[4]  http://gad.qq.com/article/detail/27474<br>
[5]  http://blog.csdn.net/wpapa/article/details/72721104</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Blender BGE 中character的滑动问题 ]]></title>
        <id>https://ayosi1996.github.io/post/g4TOJ2oJ2/</id>
        <link href="https://ayosi1996.github.io/post/g4TOJ2oJ2/">
        </link>
        <updated>2019-03-18T01:32:28.000Z</updated>
        <summary type="html"><![CDATA[<p>在Blender 的游戏引擎中使用character物理时，发现控制character移动时，如果角色静止在一个特别小的斜坡上，都会发生滑动现象，尝试着增加了地面的摩擦力，问题依然存在</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Blender 的游戏引擎中使用character物理时，发现控制character移动时，如果角色静止在一个特别小的斜坡上，都会发生滑动现象，尝试着增加了地面的摩擦力，问题依然存在</p>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://ayosi1996.github.io/post-images/1584293196723.gif" alt="" loading="lazy"></figure>
<p>原因是角色在静止不动时，受重力影响向下滑动。角色的所有运动全是靠按键驱动，所以可以写一个脚本，判断当角色在地面上且没有按键时，将重力设置为 0，即不受重力影响</p>
<h2 id="具体步骤">具体步骤</h2>
<ul>
<li>
<p>首先为角色添加Character物理属性（中文翻译应该是角色这里）<br>
<img src="https://ayosi1996.github.io/post-images/1584293207154.png" alt="" loading="lazy"></p>
</li>
<li>
<p>在逻辑编辑器中为角色添加以下节点<br>
<img src="https://ayosi1996.github.io/post-images/1584293240459.png" alt="" loading="lazy"></p>
</li>
<li>
<p>anti slide脚本：</p>
</li>
</ul>
<pre><code>import bge

def main():

    cont = bge.logic.getCurrentController()
    own = cont.owner
    ground = cont.sensors['Collision']
    
    key = cont.sensors['Keyboard']
    
    char=bge.constraints.getCharacter(own)
    
    if key.positive:
        char.gravity = 29
    else:
        if ground.positive:
            char.gravity = 0
        else:
            char.gravity = 29
main()
</code></pre>
]]></content>
    </entry>
</feed>